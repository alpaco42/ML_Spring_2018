from __future__ import division
import numpy as np
import random

class Neuron:

    @staticmethod
    def relu(array):
        return np.maximum(array, 0)

    @staticmethod
    def sigmoid(array):
        return 1 / (1 + np.exp(-1 * array))

    def __init__(self, inputs, weights = False, layer = "h"):
        self.inputs = inputs
        try:
            len(weights)
            self.weights = weights
        except TypeError:
            self.weights = np.array([[random.random() - 0.5 for i in range(inputs.shape[1])]])
        if layer == "h":
            self.act_func = Neuron.relu
        elif layer == "o":
            self.act_func = Neuron.sigmoid

    def recursive_output_calc(self, inputs = False): #doesn't like that I'm using a field from the instance in here...
        try:
            try:
                # print 0, inputs
                inputs.transpose()
                input_to_act_func = self.weights.dot(inputs.transpose())
            except AttributeError:
                # print 1, self.inputs
                input_to_act_func = self.weights.dot(self.inputs.transpose())
            return self.act_func(input_to_act_func)
        except TypeError: #this identifies if the inputs are neurons or actual numbers
            # print 2, inputs, self
            try:
                inputs.transpose()
                new_inputs = np.array([[neuron.recursive_output_calc() for neuron in inputs[0]]])
            except AttributeError:
                # print 3, self.inputs
                new_inputs = np.array([[neuron.recursive_output_calc() for neuron in self.inputs[0]]])
            return self.recursive_output_calc(inputs = new_inputs)



    # def derivative(self):

class NeuralNet:

    def __init__(self, X, y, network_structure):
        """network_structure should be a list whose length is the number of hidden layers
        and whose ith entry is the desired number of neurons in the ith hidden layer
        as of now, this only works for X = single datapoint"""

        self.network = [[Neuron(inputs = X) for i in range(network_structure[0])]]
        for layer in network_structure[1:]:
            self.network.append([Neuron(inputs = np.array([self.network[-1]])) for i in range(layer)])
        self.network.append([Neuron(inputs = np.array([self.network[-1]]), layer = "o")])

    def make_prediction(self):
        return self.network[-1][0].recursive_output_calc()
